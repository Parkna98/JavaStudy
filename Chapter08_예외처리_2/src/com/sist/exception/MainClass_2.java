package com.sist.exception;
/*
 * 		묶는 기술 => 객체지향 (누가 잘 묶어서 사용) => 재사용
 * 		1. 변수 묶는 방법
 * 			= 배열 => 같은 데이터형 (메모리 크기가 동일 => 연속적인 메모리 구조)
 * 					=> 인덱스 이용
 * 			= 클래스 => 다른 데이터형 (메모리 주소 (.))
 		2. 연산자 / 제어문
 			= 메소드 (명령문을 묶어서 사용)
 			---------------------- 한개의 기능 => 부품 (컴포넌트) => 여러개 모여서 프로그램
 			==> 조립 : 한개의 프로그램 
 			==> 게시판, 회원, 맛집, 채팅, 예약, 추천, 결제 (각각의 클래스 => 재사용성)
 			 	--------------------------------
 			 	영화 : 게시판, 회원, 예약, 추천, 결제
 			 					------------- 수정(오버라이딩)
 			----------------------------------------------------------
 			1. 가독성
 			2. 최적화 => VueJS,React(화면전환속도가 빠름)
 			3. 견고한 프로그램 => 사전에 에러를 방지하는 프로그램 
 			 				 ----
 			 				 => 예외처리**
 			   견고 => 프로그래머의 실수, 사용자 입력이 잘못된 경우
 			   --------------------------------------
 		= 예외처리
 			=> 정의 : 사전에 에러를 방지
 			=> 목적 : 비정상 종료를 방지하고 정상 종료를 할 수 있게 만든다
 			----
 			----
 			---- 에러 => 건너뜀 => catch => 에러수정을 위한 확인
 										 에러를 복구
 			----
 			----
 			=> 예외처리
 				1) 에러 복구 => try~catch
 				2) 에러 무시 => 에러 회피 => throws
 				3) 견고한 프로그램
 				   ----------- 에러발생 (임의발생) => throw 
 				4) 프로그램은 항상 .....
 				   모든 것을 지원하지 않는다
 				   => 사용자 정의
 				   => 예약, 추천, 결제...
 				   => 사용자 정의 데이터형 Music,Movie...
 				   	  => 기존의 데이터형을 모아서 새로운 데이터형을 제작
 				   	  	 => class
 				   => 사용자 정의 메소드
 				   => 예외처리가 없는 경우 => 사용자 정의 예외처리
 				---------------------------------------
 				결제모듈 => 보안처리 => 데이터베이스 연동 
 				-------------------------------
 				  ㅣ 솔루션 => 개발,SM / 영업,운영
 				   ------------------------- 인원 : 20명 (솔루션)
 				   								   50명 (SI,신규), 150명
 			=> 예외복구
 				형식) 
 					try
 					{
 						=> 정상적으로 수행할 수 있는 명령문
 						=> 평상시 코딩
 						문장 1
 						문장 2 
 						----------------
 						문장 3 ==> 에러발생 (수행하지 않고 => catch로 이동)
 						문장 4
 						문장 5
 						---------------- 무시 => catch로 이동
 					}catch(예외처리 클래스)
 					{
 						=> try안에 있는 명령문에서 오류 발생시에
 							예외처리 / 복구
 					} => 여러개 사용 가능(다중 catch)
 					finally ==> 생략가능(필요한 경우에만 사용)
 					{
 						=> try,catch를 수행하든 관계없이 무조건 수행하는 문장
 						=> 1) 서버 닫기 
 						   2) 오라클 닫기
 						   3) 파일 닫기
 					}
 					실행 
 					문장1
 					문장2
 					try
 					{
 						문장3
 						문장4
 						문장5
 					}catch(예외처리 클래스)
 					{
 						문장6
 					}
 					finally
 					{
 						문장7 (무조건수행)
 					}
 				    문장8 ==> 종료
 				    
 				    정상수행 : 1=>2=>3=>4=>5=>7=>8  ===> try가 정상이면 catch는 수행하지 않는다
 				    								  (if ~ else)
 				   	문장4에러 :1=>2=>3=>6=>7=>8 
 				   	
 				   	try{
 				   		문장1
 				   		문장2 ==> C에러 발생
 				   		문장3
 				   		   ㅣ C
 				   	}catch(A){ 
 				   		A에 대한 에러 복구 => finally 이동
 				   		   ㅣ
 				   	}catch(B){
 				   		B에 대한 에러 복구 => finally 이동
 				   		   ㅣ
 				   	}catch(C){
 				   		C에 대한 에러 복군 => finally 이동
 				   	}finally{
 				   		닫기
 				   	}
 				   	catch는 해당 영역에 한번만 수행하고===> 종료
 				   	
 				   	ex)
 				   	int[] arr=new int[2];
 				   	arr[2]=Integer.parseInt(" 10"); => parseInt쪽에서 먼저 에러발생
 				   		   							  ----------------------
 				   		   							  에러 수정후 arr[2]에서 에러발생
 			-------------------------------------------------------------------
 			
 				   		  
 				   	
 */
import java.io.*;
public class MainClass_2 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		FileReader fr=null;  // 문자스트림 (인풋스트림은 1byte씩이라 한글깨짐)
		// 파일에 null값 안넣으면 오류 => 오류가 나도 파일을 닫아야하기때문에
		try {
			fr=new FileReader("c:\\javaDev\\movie.txt");
			// String data=""; // Ajax
			StringBuffer sb=new StringBuffer(); // Vue
			int i=0;
			while((i=fr.read())!=-1) {
				sb.append((char)i);
			} 
			System.out.println(sb.toString()); // Vue와 Ajax의 속도차이가 매우많이남
		}catch(IOException e){
			// 오류발생 ==> 에러확인
			/*
			 *   getMessage() => 에러메세지 => null
			 *   printStackTrace() => 권장
			 *   	  ------------
			 *   		 ㅣ 
			 *   		실행 => 순서 => 멈춘다 ==> 에러 위치 확인
			 */
			e.printStackTrace(); // 에러내용 출력
		}
		finally { // finally는 try~catch를 안주면 오류날때 있음 (주는것이 기본이라고생각)
			try {
				fr.close();
			}catch(IOException e) {}
		}
	}

}
