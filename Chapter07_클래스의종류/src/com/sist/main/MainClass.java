package com.sist.main;
/*		
 * 		언어 : 자바 파이썬 C/C++ Kotlin c# 스칼라 ...
 * 		ML : HTML XML WML HDML VML...
 * 		JavaScript : Jquery(AJax), Vue, React, TypeScript, coffieScript, NodeJs....
 * 											   ----------급부상
 * 		기술 : Spring, Spring-Boot
 * 		구조 : AWS / MSA
 * 		이외 : R, NumPy, Pandas, MatPlotLib => 아나콘다
 * 			=> 머신러닝/딥러닝
 * 		------------------------------------------------------------------------------
 * 		IT => 전진 => 앞만 보고 => 모르는 부분만 공부
 * 		=====> 실무는 구현 (이론:면접)
 * 	
 * 	   자바
 * 		= 데이터형 => 변수 (2장)
 * 			정수 : byte, 		int, 	long
 * 				 -----				-----
 * 				  ㅣ파일입출력(io)		ㅣ데이터분석(빅데이터)
 * 			실수 : double 
 * 			논리 : boolean 
 * 			문자열 : String
 * 			
 * 		= 처리 => 연산자/제어문 (3장,4장)
 * 			단항연산자 : 증가연산자(++,--), !(부정연산자), (type)(형변환연산자)
 *					=> 형변환 : 자동형변환(묵시적) / 강제형변환(명시적)
 *					   ----- 클래스도 적용
 *							 ---- 크기비교(상속,포함) => instanceof 
 *			이항연산자 : 산술연산자(+,-,*,/,%)
 *					  비교연산자(==,!=,<,>,<=,>=)
 *					  논리연산자(&&,||)
 *					  대입연산자(=, +=, -=)
 *			삼항연산자 : (조건)?값1:값2
 *			
 *			제어문 : 조건문
 *					-----------------------**
 *					if(조건문) => 단일조건문
 *					if~else => 선택조건문
 *					-----------------------
 *					if~else if => 다중조건문
 *				   반복문
 *					for(화면출력), while(데이터베이스, 파일)
 *					 Front			Back
 *				   반복제어문
 *					break=>반복문 종료
 *							  				
 * 			배열 => 1차원  (코테는 가끔2차원나오는듯)
 * 				=> 클래스 배열 Music[] String[] ===> 컬렉션! (배열 보완) List,Set,Map
 * 			
 * 			클래스 (5,6,7장)
 * 			=> 구성요소
 * 			  -------
 * 				멤버변수
 * 					= 인스턴스 변수		===> 메모리를 따로저장
 * 					= 정적 변수(static) ===> 메모리 공간을 한개만 사용
 * 					----------------
 * 						=> 디자인패턴 : 싱글턴 패턴 => DB연동
 * 						=> 팩토리패턴
 * 						=> 스프링 => 8개 패턴 (컴바인드 패턴)
 * 					= 데이터 보호 => 캡슐화 => private => getter/setter
 * 					
 * 				생성자
 * 				 	= 멤버 변수 초기화, 시작과 동시에 처리
 * 					= 메모리 할당시 호출
 * 					= 클래스는 무조건 생성자 1개이상이 필요하다
 * 						=> 없는 경우에는 자동으로 1개 추가 (default 생성자)
 * 					*** 자동 추가
 * 					1) import 자동 추가
 * 					   import java.lang.*
 * 							  ----------- String, Math, Object, System
 * 					2) 모든 클래스(라이브러리, 사용자 정의 클래스)
 * 						=> 상속 (Object)
 * 						class MainClass (extends Object)
 * 					3) 모든 메소드는 return(메소드 종료)
 * 						=> void일 경우에는 자동 return이 추가
 * 						void aaa()
 * 						{
 * 							// return;
 * 						}
 * 					4) class A
 * 					   {
 * 						  ---------------
 * 							public A(){}  자동추가
 * 						  ---------------
 * 					   }
 * 					5) 자바에서 지원하는 모든 클래스는 예외처리
 * 					   CheckException, UnCheckException
 * 							ㅣ		   ----------------- 예외처리 생략가능
 * 						반드시 예외처리
 * 							=> 네트워크 : URL, Socket..
 * 								  IO : 파일 입출력
 * 								 SQL : 오라클 연결
 * 						생성자를 사용하지 않고 초기화 방법
 * 						-------------------------
 * 							초기화 블록
 * 								= 인스턴스 블록 => 생성자를 보통씀 (인스턴스블록은 잘 안씀)
 * 								= static 블록
 * 									=> static 변수 => 생성자를 호출하지 않아도 된다 (static변수는 자동메모리할당)
 * 		
 * 								*** 먼저 명시적 초기화 => 불가능할때 생성자, 초기화불록 사용
 * 													----- 외부에서 값을 읽어와서 초기화 할때
 * 														  크롤링,파일읽기,네트워크 ...				
 * 			
 * 				메소드
 * 				 = 다른 클래스와 연결
 * 				 = 인스턴스 메소드 : 메모리에 따로 저장
 * 					=> 호출 :  객체명.메소드()
 * 							  ----
 * 							  scan.next()
 * 							  ss.replace()
 * 				 = 정적 메소드 : 공유(한개의 메소드로 모든 객체 사용)
 * 					=> 한글변환(웹)
 * 					=> 호출 : 클래스명.메소드() 
 * 							-------
 * 							Math.random()
 * 							String.valueOf()
 * 					=> 메소드
 * 					   접근지정어 : public
 * 					   리턴형 : 기본형, 클래스형, 배열
 * 									----------- 
 * 							=> 결과값 1개
 * 							=> 목록, 상세보기, 검색결과 => 배열, 클래스
 * 					   메소드명 : 식별자 , 소문자로시작
 * 					   매개변수 : 여러개 사용 => 사용자 요청값 => 3개이상이면 배열,클래스 권장
 * 								=> 회원가입, 게시물 글쓰기, 영화정보 => 클래스가 효율적
 *				 				
 *			= 6장 : 객체지향 3대 특성
 *					= 문법이 아니다, 권장사항!
 *				1) 캡슐화   : 데이터 보호
 *					=> 변수를 은닉화 : private
 *					=> 기능설정 => getter/setter => Lombok (라이브러리)
 *				2) 재사용기법 : 상속/포함
 *						상속 => 기존의 클래스를 확장, 필요시에 변경 (오버라이딩) // 오버로딩은 새로운 기능 추가
 *							class A
 *							class B extends A
 *						포함 => 클래스를 변경하지 않는 상태로 사용
 *							class A
 *							class B {
 *								A a=new A(); ==> 강제로 변경가능 => 익명의 클래스 (기본은 변경하지않고 사용(포함))
 *							}
 *						상속의 예외 조건 : static(공유), 생성자, 초기화 블록, private(상속O 접근X)
 *							
 *						상속 => 클래스의 크기 => 형변환
 *							자동 형변환(묵시적 형변환)
 *							강제 형변환(명시적 형변환) => 작은 클래스에서 큰 클래스 받을때 => 작은클래스로 형변환 필수
 *							class A
 *							class B extends A ===> A > B
 *							A a=new B(); 
 *							------------
 *							B b=new B();
 *							A a=b; // 자동 형변환
 *							
 *							A a=new B();
 *							B b=(B)a; // 강제 형변환 (자주등장)
 *							---------------------
 *							리턴형 => 클래스형
 *							 => 라이브러리에서 클래스형 리턴
 *								--------------------
 *								=> Object를 리턴하는 경우가 많다 => Object를 형변환해서 받아야 경우가 생김
 *							Music getData(){}
 *
 *				3) 다형성 (변경 / 추가)
 *					변경 : 오버라이딩
 *					추가 : 오버로딩
 *
 *						오버로딩				오버라이딩
 *				-----------------------------------------
 *				상태		같은 클래스				상속을 받은 경우
 *				-----------------------------------------
 *				리턴형	관계 없음				동일
 *				-----------------------------------------
 *				메소드명	동일					동일
 *				-----------------------------------------
 *				매개변수	갯수나 데이터형 다름		동일
 *				-----------------------------------------
 *				접근지정어	관계없음				축소X 확장O
 *				-----------------------------------------
 *					<================ 축소 ======== 
 *					private < default < protected < public
 *					================= 확대 ========>
 *
 *				interface A  ====> 인터페이스는 무조건 public임 (생략가능)
 *				{
 *					(public abstract)void disp();
 *					void aaa();
 *				}
 *				=> class B implements A
 *				   {
 *						void disp(){};	
 *						void aaa(){}; ===> A가 public인데 default로 축소되서 오류 => public으로 받아야함
 *						----------------- 오류 (오버라이딩 조건임)
 *				   }
 *
 */
import java.util.*;
/*
 * 		class A
 * 		{
 * 			void display(){}
 * 		}
 * 		class B extends A
 * 		{
 * 			int a,b;
 * 			void aaa(){}
 * 			-------------
 * 			void display(){} => 변경하면 오버라이딩
 * 			-------------
 * 		}
 * 		A a=new B(); ====> 추상클래스 / 인터페이스
 * 	   ----- a.display()에만 접근가능
 * 		B b=new B():
 * 	   ----- a,b, b.aaa(), b.display()
 * 		
 */	
public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		List names=new ArrayList();
		// 배열 대신 사용
		names.add("홍길동"); // add(), get() 등의 메소드는 Object를 리턴한다
		// String name=names.get(0); => 홍길동의 값은 Object라 String에 저장불가 => 형변환 필요
		String name=(String)names.get(0); // (String)Object로 형변환
	}

}
